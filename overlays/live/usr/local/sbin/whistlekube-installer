#!/bin/bash
# This is the main installer script that runs in the live environment

set -euo pipefail

export DEBIAN_FRONTEND=noninteractive

# Define paths
CDROM_MOUNT="/run/live/medium"  # live-boot typically mounts the installation media here
TARGET_SQUASHFS="${CDROM_MOUNT}/install/filesystem.squashfs"
TARGET_MNT="/target"
EFI_MNT="${TARGET_MNT}/boot/efi"

# Colors for better UI
GREEN='\033[0;32m'
BLUE='\033[0;34m'
RED='\033[0;31m'
NC='\033[0m'  # No Color

# Function to set up dialog UI
setup_ui() {
    # Configure dialog settings
    export DIALOGRC="/etc/dialogrc"
    export DIALOG_BACKTITLE="Whistlekube Installer"
}

# Function to check if the system is UEFI
is_uefi() {
    if [ -d "/sys/firmware/efi" ]; then
        return 0  # UEFI
    else
        return 1  # Legacy BIOS
    fi
}

# Function to partition disk
partition_disk() {
    local disk="$1"

    # Show partitioning dialog
    dialog --title "Partitioning" --yesno "This will erase all data on $disk. Continue?" 8 60
    if [ $? -ne 0 ]; then
        return 1
    fi

    # Create partitions
    if is_uefi; then
        parted -s "$disk" mklabel gpt
        parted -s "$disk" mkpart primary fat32 1MiB 513MiB
        parted -s "$disk" set 1 esp on
        parted -s "$disk" mkpart primary ext4 513MiB 100%
    else
        parted -s "$disk" mklabel msdos
        parted -s "$disk" mkpart primary ext4 1MiB 100%
        parted -s "$disk" set 1 boot on
    fi

    # Wait for udev to settle and recognize the new partitions
    sleep 2
    udevadm settle
    
    # Determine the device names for the partitions
    if [[ "$disk" == *nvme* ]]; then
        # NVMe devices use "p" suffix for partitions (e.g., /dev/nvme0n1p1)
        if is_uefi; then
            efi_part="${disk}p1"
            root_part="${disk}p2"
        else
            root_part="${disk}p1"
        fi
    else
        # SATA/IDE devices add partition number (e.g., /dev/sda1)
        if is_uefi; then
            efi_part="${disk}1"
            root_part="${disk}2"
        else
            root_part="${disk}1"
        fi
    fi

    # Format the partitions
    if is_uefi; then
        mkfs.fat -F32 "$efi_part"
        echo "EFI partition formatted: $efi_part"
    fi

    mkfs.ext4 -F "$root_part"
    echo "Root partition formatted: $root_part"

    # Create mount points
    mkdir -p "$TARGET_MNT"

    # Mount root partition
    mount "$root_part" "$TARGET_MNT"

    # Mount EFI partition if UEFI
    if is_uefi; then
        mkdir -p "$EFI_MNT"
        mount "$efi_part" "$EFI_MNT"
    fi

    return 0
}

# Function to extract the rootfs
extract_rootfs() {
    echo -e "${BLUE}Extracting root filesystem...${NC}"

    # Ensure temp directory exists
    mkdir -p "$TARGET_MNT"

    # Extract the squashfs to the target
    unsquashfs -f -d "$TARGET_MNT" "$TARGET_SQUASHFS"

    echo -e "${GREEN}Root filesystem extracted!${NC}"
    sleep 1
}

# Function to mount target filesystem
mount_target() {
    local disk="$1"

    # Create mount point
    mkdir -p "$TARGET_MOUNT"

    # Mount root partition
    mount "${disk}2" "$TARGET_MOUNT"

    # Create and mount boot/efi
    mkdir -p "$TARGET_MOUNT/boot/efi"
    mount "${disk}1" "$TARGET_MOUNT/boot/efi"
}

# Function to install system
install_system() {
    dialog --title "Installing" --infobox "Installing system files..." 5 70

    # Mount squashfs if not already mounted
    if [ ! -d "/mnt/squashfs" ]; then
        mkdir -p /mnt/squashfs
        mount -t squashfs -o ro "$TARGET_SQUASHFS" /mnt/squashfs
    fi

    # Copy files (use rsync for better progress reporting)
    rsync -a /mnt/squashfs/ "$TARGET_MOUNT/"

    # Clean up
    umount /mnt/squashfs
}

### Function to install bootloader
##install_bootloader() {
##    local disk="$1"
##
##    # Chroot and install GRUB
##    for dir in /dev /proc /sys; do
##        mount --bind $dir "$TARGET_MOUNT$dir"
##    done
##
##    chroot "$TARGET_MOUNT" grub-install "$disk"
##    chroot "$TARGET_MOUNT" update-grub
##
##    # Unmount
##    for dir in /sys /proc /dev; do
##        umount "$TARGET_MOUNT$dir"
##    done
##}

# Function to configure system
configure_system() {
    #local root_part="$1"
    #local efi_part="$2"

    echo -e "${BLUE}Configuring the installed system...${NC}"

    # Generate fstab
    UUID_ROOT=$(blkid -s UUID -o value "$root_part")
    echo "# /etc/fstab: static file system information" > "$TARGET_MNT/etc/fstab"
    echo "# <file system> <mount point> <type> <options> <dump> <pass>" >> "$TARGET_MNT/etc/fstab"
    echo "UUID=$UUID_ROOT / ext4 errors=remount-ro 0 1" >> "$TARGET_MNT/etc/fstab"

    # Add EFI partition to fstab if UEFI
    if is_uefi; then
        UUID_EFI=$(blkid -s UUID -o value "$efi_part")
        echo "UUID=$UUID_EFI /boot/efi vfat umask=0077 0 1" >> "$TARGET_MNT/etc/fstab"
    fi

    # Set hostname
    echo "whistlekube" > "$TARGET_MNT/etc/hostname"
    echo "127.0.1.1 whistlekube" >> "$TARGET_MNT/etc/hosts"

    # Bind mount essential filesystems for chroot
    mount --bind /dev "$TARGET_MNT/dev"
    mount --bind /dev/pts "$TARGET_MNT/dev/pts"
    mount --bind /proc "$TARGET_MNT/proc"
    mount --bind /sys "$TARGET_MNT/sys"

    echo -e "${GREEN}System configuration completed!${NC}"
    sleep 1
}

# Function to install and configure the bootloader
install_bootloader() {
    local disk="$1"

    echo -e "${BLUE}Installing bootloader...${NC}"

    # Move sources.list files to prevent using Debian mirrors
    local sources_backup=/tmp/sources.list.d.backup
    mkdir -p "${sources_backup}/sources.list.d"
    mv "${TARGET_MNT}/etc/apt/sources.list" "${sources_backup}/" || true
    mv "${TARGET_MNT}/etc/apt/sources.list.d/"* "${sources_backup}/sources.list.d/" || true

    # Set up the local repository in the target system
    mkdir -p "${TARGET_MNT}/etc/apt/sources.list.d/"
    echo "deb [trusted=yes] file:///cdrom trixie main" > "${TARGET_MNT}/etc/apt/sources.list.d/local-install.list"

    # Mount the cdrom inside the chroot
    mkdir -p "${TARGET_MNT}/cdrom"
    mount --bind "${CDROM_MOUNT}" "${TARGET_MNT}/cdrom"

    # Update apt with the local repository
    chroot "$TARGET_MNT" apt-get update

    # Configure GRUB for the target system
    if is_uefi; then
        echo "Installing GRUB for UEFI system..."
        
        # Install GRUB packages for UEFI using apt
        chroot "$TARGET_MNT" apt-get install -y --no-install-recommends grub-efi-amd64
        
        # Install GRUB to the EFI partition
        chroot "$TARGET_MNT" grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=WhistleKube --no-floppy --recheck 

    else
        echo "Installing GRUB for BIOS system..."

        # Install GRUB packages for BIOS using apt
        chroot "$TARGET_MNT" apt-get install -y --no-install-recommends grub-pc

        # Install GRUB to the MBR
        chroot "$TARGET_MNT" grub-install --target=i386-pc --boot-directory=/boot "$disk" --no-floppy --recheck
    fi

    # Generate the grub.cfg file
    chroot "$TARGET_MNT" update-grub

    # Remove the local repository and set up proper Debian mirrors
    rm -f "${TARGET_MNT}/etc/apt/sources.list.d/local-install.list"
    mv "${sources_backup}/sources.list" "${TARGET_MNT}/etc/apt/sources.list"
    mv "${sources_backup}/sources.list.d" "${TARGET_MNT}/etc/apt/sources.list.d"
    rm -rf "${sources_backup}"
    umount "${TARGET_MNT}/cdrom"

    # Update apt with the real repository
    chroot "$TARGET_MNT" apt-get update

    echo -e "${GREEN}Bootloader installation completed!${NC}"
    sleep 1
}

# Function to clean up and finish installation
finish_installation() {
    echo -e "${BLUE}Finalizing installation...${NC}"
    
    # Unmount all filesystems
    umount -l "$TARGET_MNT/dev/pts" 2>/dev/null || true
    umount -l "$TARGET_MNT/dev" 2>/dev/null || true
    umount -l "$TARGET_MNT/proc" 2>/dev/null || true
    umount -l "$TARGET_MNT/sys" 2>/dev/null || true
    
    if is_uefi; then
        umount "$EFI_MNT" 2>/dev/null || true
    fi
    
    umount "$TARGET_MNT" 2>/dev/null || true
    
    echo -e "${GREEN}Installation completed successfully!${NC}"
    echo "You can now reboot into your new WhistleKube Linux system."
    read -p "Press Enter to continue..." dummy
}

# Main installation workflow
main() {
    setup_ui

    local welcome_msg="Welcome to the Whistlekube Installer!\n\n \
    This will install a minimal Whistlekube system to the selected disk. \
    The configuration can be completed after the installation is complete via the web interface.\n\n \
    Documentation at https://whistlekube.com/docs"
    if ! dialog --yes-label "Install" --no-label "Shell" --yesno "$welcome_msg" 15 60; then
        dialog --title "Shell" --msgbox "Entering shell..." 5 40
        /bin/bash
        exit 0
    fi

    # Check if running as root
    if [ "$(id -u)" -ne 0 ]; then
        echo -e "${RED}This script must be run as root!${NC}"
        exit 1
    fi

    # Check if target squashfs exists
    if [ ! -f "$TARGET_SQUASHFS" ]; then
        echo -e "${RED}Target squashfs file not found: $TARGET_SQUASHFS${NC}"
        exit 1
    fi

    # Select disk to install to
    disk=$(dialog --stdout --title "Disk Selection" --menu "Select disk to install to:" 15 60 5 \
        $(lsblk -d -o NAME,SIZE -n -e 7,11 | awk '{print "/dev/"$1 " " $2}'))

    if [ -z "$disk" ]; then
        dialog --title "Cancelled" --msgbox "Installation cancelled." 5 40
        exit 1
    fi

    # Perform installation steps
    if ! partition_disk "$disk"; then
        dialog --title "Failed to partition disk" --msgbox "Installation failed. Error partitioning ${disk}." 5 40
        exit 1
    fi

    extract_rootfs
    #mount_target "$disk"
    #install_system
    configure_system
    install_bootloader "$disk"
    read -p "Press Enter to continue..." dummy
    finish_installation

    # Unmount target
    #umount -R "$TARGET_MOUNT"

    # Installation complete
    dialog --title "Installation Complete" --msgbox "Firewall system has been installed. The system will now reboot." 7 60

    # Reboot
    reboot
}

# Start installation
main

